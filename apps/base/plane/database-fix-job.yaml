apiVersion: batch/v1
kind: Job
metadata:
  name: plane-database-fix
  namespace: plane
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
spec:
  template:
    spec:
      serviceAccountName: plane-database-fixer
      restartPolicy: OnFailure
      containers:
      - name: kubectl
        image: bitnami/kubectl:latest
        command:
        - /bin/bash
        - -c
        - |
          echo "Waiting for plane-app-secrets to be created..."
          while ! kubectl get secret plane-app-secrets -n plane >/dev/null 2>&1; do
            echo "Waiting for app secrets..."
            sleep 5
          done
          
          echo "Getting external database credentials..."
          POSTGRES_USER=$(kubectl get secret plane-secret -n plane -o jsonpath='{.data.POSTGRES_USER}' | base64 -d)
          POSTGRES_PASSWORD=$(kubectl get secret plane-secret -n plane -o jsonpath='{.data.POSTGRES_PASSWORD}' | base64 -d)
          POSTGRES_DB=$(kubectl get secret plane-secret -n plane -o jsonpath='{.data.POSTGRES_DB}' | base64 -d)
          SECRET_KEY=$(kubectl get secret plane-secret -n plane -o jsonpath='{.data.SECRET_KEY}' | base64 -d)
          
          # URL encode the password for safety
          ENCODED_PASSWORD=$(echo -n "$POSTGRES_PASSWORD" | sed 's/@/%40/g; s/:/%3A/g; s/\//%2F/g; s/ /%20/g')
          
          # Get database host - try hostname first, fall back to IP if DNS fails
          DB_HOST="postgres-arasaka-postgresql.database-arasaka.svc.cluster.local"
          echo "Testing DNS resolution for $DB_HOST..."
          
          # Test if we can resolve the hostname - use timeout to avoid hanging
          if ! timeout 10 nslookup "$DB_HOST" >/dev/null 2>&1; then
            echo "DNS resolution failed, attempting to get service IP..."
            DB_IP=$(kubectl get service postgres-arasaka-postgresql -n database-arasaka -o jsonpath='{.spec.clusterIP}' 2>/dev/null || echo "")
            if [ -n "$DB_IP" ] && [ "$DB_IP" != "None" ]; then
              DB_HOST="$DB_IP"
              echo "Using database service IP: $DB_HOST"
            else
              echo "Could not resolve database service IP, trying endpoints..."
              DB_IP=$(kubectl get endpoints postgres-arasaka-postgresql -n database-arasaka -o jsonpath='{.subsets[0].addresses[0].ip}' 2>/dev/null || echo "")
              if [ -n "$DB_IP" ]; then
                DB_HOST="$DB_IP"
                echo "Using database endpoint IP: $DB_HOST"
              else
                echo "Warning: Could not resolve database IP, using original hostname"
              fi
            fi
          else
            echo "DNS resolution successful for $DB_HOST"
          fi
          
          # Construct external database URL
          EXTERNAL_DB_URL="postgresql://${POSTGRES_USER}:${ENCODED_PASSWORD}@${DB_HOST}:5432/${POSTGRES_DB}"
          
          echo "Updating plane-app-secrets with external database..."
          kubectl patch secret plane-app-secrets -n plane --type=json -p="[
            {\"op\": \"replace\", \"path\": \"/data/DATABASE_URL\", \"value\": \"$(echo -n "$EXTERNAL_DB_URL" | base64 -w 0)\"},
            {\"op\": \"replace\", \"path\": \"/data/SECRET_KEY\", \"value\": \"$(echo -n "$SECRET_KEY" | base64 -w 0)\"}
          ]"
          
          echo "Scaling down embedded PostgreSQL (using external Arasaka DB instead)..."
          kubectl scale statefulset plane-pgdb-wl --replicas=0 -n plane 2>/dev/null || echo "No embedded PostgreSQL to scale down"
          
          echo "Waiting for embedded databases to scale down..."
          sleep 10
          
          echo "Restarting plane API pods to pick up new database config..."
          kubectl rollout restart deployment/plane-api-wl -n plane
          kubectl rollout restart deployment/plane-beat-worker-wl -n plane
          kubectl rollout restart deployment/plane-worker-wl -n plane
          
          # Also ensure other service URLs use proper hostnames (not IPs)
          echo "Ensuring all service connections use proper hostnames..."
          
          # Set proper AMQP and Redis URLs using hostnames
          AMQP_URL="amqp://plane:plane@plane-rabbitmq.plane.svc.cluster.local/"
          REDIS_URL="redis://plane-redis.plane.svc.cluster.local:6379/"
          
          echo "Updating all service URLs to use hostnames..."
          kubectl patch secret plane-app-secrets -n plane --type=json -p="[
            {\"op\": \"replace\", \"path\": \"/data/AMQP_URL\", \"value\": \"$(echo -n "$AMQP_URL" | base64 -w 0)\"},
            {\"op\": \"replace\", \"path\": \"/data/REDIS_URL\", \"value\": \"$(echo -n "$REDIS_URL" | base64 -w 0)\"}
          ]"
          
          echo "Database and service configuration updated successfully!"
          echo "DATABASE_URL: $EXTERNAL_DB_URL"
          echo "AMQP_URL: $AMQP_URL"
          echo "REDIS_URL: $REDIS_URL"
          
          echo "Waiting for deployments to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/plane-api-wl -n plane || echo "API deployment wait timed out"
          kubectl wait --for=condition=available --timeout=300s deployment/plane-worker-wl -n plane || echo "Worker deployment wait timed out"
          
          echo "All deployments updated with external Arasaka database and proper service hostnames!"
